<?php

/**
 * @file
 * Provides core functionality for wcag_scheduler.
 */

define('WCAG_SCHEDULER_TABLE', 'wcag_scheduler_reports');
define('WCAG_SCHEDULER_LAST_RUN', '0');
define('WCAG_SCHEDULER_ZULU_START', '0001');
define('WCAG_SCHEDULER_ZULU_FINISH', '0700');
define('WCAG_SCHEDULER_FREQUENCY', '86400');

/**
 * Implements hook_views_api().
 */
function wcag_scheduler_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_module_implements_alter().
 */
function wcag_scheduler_module_implements_alter(&$module_list, $context) {
  if ($context === "menu_alter") {
    $temp = $module_list['wcag_scheduler'];

    // Removing the mymodule key/value.
    unset($module_list['wcag_scheduler']);

    // Adding the mymodule key value as the last member in the list.
    $module_list['wcag_scheduler'] = $temp;
  }
}

/**
 * Implements hook_permission().
 */
function wcag_scheduler_permission() {
  return array(
    'View WCAG Scheduler' => array(
      'title' => t('View WCAG Scheduler'),
    ),
    'Administer WCAG Scheduler' => array(
      'title' => t('Administer WCAG Scheduler'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function wcag_scheduler_menu() {
  $items = array();

  // Sechduler configuration page.
  $items['admin/config/services/wcag-scheduler'] = array(
    'title' => 'WCAG Scheduler',
    'description' => 'Configure the WCAG Scheduler for page submissions.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wcag_scheduler_config_form'),
    'access arguments' => array('Administer WCAG Scheduler'),
    'file' => 'wcag_scheduler.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function wcag_scheduler_menu_alter(&$items) {
  if (!empty($items['admin/reports/wcag-scheduler'])) {
    // Scheduler results page.
    $items['admin/reports/wcag-scheduler']['title'] = 'WCAG Scheduler Results';
    $items['admin/reports/wcag-scheduler']['type'] = MENU_NORMAL_ITEM;
    $items['admin/reports/wcag-scheduler']['description'] = 'View the results provided from WCAG Scheduler.';
  }
}

/**
 * Implements hook_cron().
 */
function wcag_scheduler_cron() {
  global $base_url;

  // Variables.
  $zulu_current = date('Gi');
  $zulu_start = variable_get('wcag_scheduler_zulu_start', WCAG_SCHEDULER_ZULU_START);
  $zulu_finish = variable_get('wcag_scheduler_zulu_finish', WCAG_SCHEDULER_ZULU_FINISH);
  $unix_current = time();
  $unix_diff = variable_get('wcag_scheduler_frequency', WCAG_SCHEDULER_FREQUENCY);
  $unix_last_post = variable_get('wcag_scheduler_last_run', WCAG_SCHEDULER_LAST_RUN);

  // wcag_validate related variables.
  $server_base = variable_get('wcag_validate_server_base', wcag_validate_get_config('wcag_validate_server_base'));

  // We need to check for new report data.
  $pages = _wcag_scheduler_query('/sitesummary?url=' . $base_url);
  if (!empty($pages)) {
    // Check if any of the id's exist in the database.
    $rids = array();
    $pages_to_save = array();
    foreach ($pages as $page) {
      $rids[] = $page->report_id;
      $pages_to_save[$page->report_id] = array(
        'rid' => $page->report_id,
        'url' => $page->url,
        'last_updated' => strtotime($page->last_checked),
        'major' => $page->major,
        'minor' => $page->minor,
        'suggestions' => $page->suggestion,
      );
    }

    // Filter out existing records.
    $existing_rids = db_query("SELECT rid FROM {wcag_scheduler_reports} WHERE rid IN (:rids)", array(":rids" => $rids))->fetchCol();
    foreach ($existing_rids as $existing_rid) {
      unset($pages_to_save[$existing_rid]);
    }

    // Save the values.
    _wcag_scheduler_save_reports($pages_to_save);

    // Rebuild the latest if we import records.
    if (!empty($pages_to_save)) {
      _wcag_scheduler_rebuild_latest($rids);
    }
  }

  // We need to ensure that we are checking within the time frame.
  if ($zulu_current <= $zulu_start || $zulu_current >= $zulu_finish) {
    return;
  }

  // Send a new one for processing if we havent sent on in the past duration.
  if ($unix_last_post == 0 || ($unix_last_post - $unix_current) >= $unix_diff) {

    // Submit a request.
    $json = _wcag_scheduler_send_request();

    // Check the response.
    switch ($json->response) {
      case "Added new queue Item":
        watchdog('wcag_scheduler', 'Added a new item to the queue for validation.');
        break;

      case "Queue Item exists already":
        watchdog('wcag_scheduler', 'Tried to queue for validation however an item is already in the queue.');
        break;

      default:
        watchdog('wcag_scheduler', 'An error occurred while trying to submit to the queue.');

    }

    // We also want to set the last run.
    variable_set('wcag_scheduler_last_run', $unix_current);
  }
}

/**
 * Builds a guzzle object.
 */
function _wcag_scheduler_query($query = '') {
  // Ensure we have a query string.
  if (empty($query)) {
    return;
  }

  $server_base = variable_get('wcag_validate_server_base', wcag_validate_get_config('wcag_validate_server_base'));

  // Setup a Guzzle submission.
  $client = new Guzzle\Service\Client();
  $request = $client->get($server_base . $query);
  $response = $request->send();
  $response->getBody(TRUE);
  $json = json_decode($response->getBody(TRUE));

  return $json;
}

/**
 * Sends a request to the service.
 */
function _wcag_scheduler_send_request() {
  global $base_url;

  // Build a query and submit.
  $query = '/queue/add?uri=' . $base_url;
  if (drupal_valid_path('sitemap.xml')) {
    $query .= '&sitemap=1';
  }
  $json = _wcag_scheduler_query($query);

  return $json;
}

/**
 * Helper function to save records to the wcag_schduler table.
 */
function _wcag_scheduler_save_reports($reports) {
  if (db_table_exists(WCAG_SCHEDULER_TABLE)) {
    $fields = array(
      'rid',
      'url',
      'last_updated',
      'major',
      'minor',
      'suggestions',
    );

    // Prepare insert query.
    $insert = db_insert(WCAG_SCHEDULER_TABLE);
    $insert->fields($fields);

    foreach ($reports as $report) {
      $insert->values($report);
    }
    $insert->execute();
  }
}

/**
 * Helper function to rebuild the database for the latest records.
 */
function _wcag_scheduler_rebuild_latest($rids) {
  // Ensure all others are set to 0.
  db_update(WCAG_SCHEDULER_TABLE)
    ->fields(array('latest' => 0))
    ->condition('rid', $rids, 'NOT IN')
    ->execute();

  // Ensure the latest are set.
  db_update(WCAG_SCHEDULER_TABLE)
    ->fields(array('latest' => 1))
    ->condition('rid', $rids, 'IN')
    ->execute();
}
